Яндекс Практикум. DevOps. Вводное задание

* Google Site Reliability Engineering (SRE). Авторы: Бетси Байер, Ниалл Ричард Мерфи и др.
* Unix и Linux: руководство системного администратора. Авторы: Эви Немет, Гарт Снайдер, Трент Хейн и др.
* Проект «Феникс». Авторы: Бер Кевин, Спаффорд Джордж и Ким Джин.
* Серия статей про сети на Хабре: «Сети для самых маленьких» и «Сети для самых матёрых»
* Telegram-каналы с литературой: https://t.me/devopslibrary и https://t.me/bzd_channel

Пролог
* Scrum. Революционный метод управления проектами. Джефф Сазерленд.
* Постигая Agile: ценности, принципы и методологии. Эндрю Стеллман и Дженнифер Грин.


Глава 2:
	Задание 2:
* Токен учетной записи GitLab: iy_-37P3xbbxfEbx9Syx
* Токен проекта SStore в GitLab: sycuNfCYy6dq9_7PxzFp
* Slack Webhook URL: TPV9DP0N4/B04BZRR28MC/0Jov5J7iEOoZjvIcvGuixSdl
* Книга «Проект «Феникс». Три пути DevOps»

Ключевые слова needs и dependencies

Чтобы рассказать о них, расскажу про два правила, которые работают по-умолчанию
* Джобы выполняются параллельно в рамках одного стейджа, стейджи запускаются по очереди так, как заданы в самом пайплайне
* Артефакты из предыдущих джобов автоматически пробрасываются в последующие
Ключевые слова needs и dependencies управляют именно этими вещами. При этом меняют дефолтные политики в отношении артефактов и выполнения.
* Dependencies отключает скачивание артефактов из всех прочих джобов, кроме тех, которые указаны в dependencies. Нужно если мы не хотим тащить за собой все артефакты всех джобов через весь пайплайн
* Needs позволяет явно указать порядок, при котором джобы должны запускаться в рамках одного стейджа. Нужно если есть строго зависимая от другой джоба. Тогда нам важно, чтобы сначала запустилась одна, а только потом другая, иначе все сломается

Первый пункт в целом резонно добавить, если тащим что-то большое. Это поможет сделать пайплайн быстрее. Второй пункт имеет более узкие кейсы. Например, если у нас есть тест и сборка, то мы можем просто засунуть их в разные стейджи и не заниматься переопределением. Или, как было у нас в ДЗ, нотификация и сборка.


Наследование и реиспользование
В процессе написания пайплайнов вы наверняка заметили, что приходится копипастить. Внутри Gitlab CI эту проблему можно решить тремя способами:
* Наследование с помощью ключевого слова extends
* Использование якорей (YAML Anchors)
* Использование глобальной области видимости

Далее по порядку. Начнем с extends . Вот пример конфигурации:

.tests: # "Скрытая джоба". В ней мы указываем те директивы, которые будут повторяться. Например, какой-то скрипт. Или only, как здесь
  script: rake test
  stage: test
  only:
    refs:
      - branches

rspec: 
  extends: .tests # Данная строчка говорит гитлабу: возьми все директивы, что есть в джобе .tests, кроме тех, что указаны в джобе rspec
  image: ubuntu:focal
  only:
    variables:
      - $RSPEC

В результате джобу rspec можно будет описать вот так:

rspec:
  script: rake test
  stage: test
  image: ubuntu:focal
  only:
    refs:
      - branches
    variables:
      - $RSPEC

Есть еще несколько примеров, про них можно прочитать вот тут

Далее, якори. Разберем на примере:

.job_template: &job_configuration  # Задаем "скрытую джобу", давая ей алиас job_configuration  
  image: ruby:2.6
  services:
    - postgres
    - redis

test1:
  <<: *job_configuration  # Берем все содержимое скрытой джобы с алиасом job_configuration и склеиваем с заданными директивами в джобе test1
  script:
    - test1 project

test2:
  <<: *job_configuration  # Берем все содержимое скрытой джобы с алиасом job_configuration и склеиваем с заданными директивами в джобе test2
  script:
    - test2 project

Extends и якори по сути решают одну и ту же проблему. Предпочтительнее использовать первое, поскольку данный функционал более гибкий

Ну и напоследок насчет глобальной конфигурации. Тут все просто. Если мы укажем какую-то директиву не на уровне джобы, а на верхнем уровне, то она применится ко всем джобам. Пример:

image: ubuntu:latest #image будет использован для всех джобов, кроме тех, где этот параметр переопределен
my-job:
  image: ubuntu:focal #Здесь мы используем директиву на уровне джобы, соответственно, перекроем то, что выше
  stage: build

my-job-2:
  stage: build


Немного дополнений про pre-commit

Pre-commit позволяет запускать различные git хуки перед коммитом или пушем в Git репозиторий - один раз настроив, можно сэкономить много времени на запуск линтеров и анализаторов кода, ожидания проверок от CI системы, в некоторых случаях.
Хуков великое множество для разных языков программирования и задач из которых можно собрать практически любой нужный вокрфлоу

* Установить фреймворк можно через пакетный менеджер pip или homebrew для Mac OS
* После установки в корень нашего проекта необходимо добавить файл .pre-commit-config.yaml . Базовый конфиг так же можно сгенерировать командой pre-commit sample-config
* Далее можно подключать интересующие нас плагины в файл конфигурации (.pre-commit-config.yaml) . Доступные плагины можно найти и выбрать на этой странице
* После добавления плагинов нужно выполнить pre-commit install

Для нашего текущего проекта рекомендую использовать следующие хуки
* Gitlab CI Linter - один из нескольких линтеров для Gitlab-CI
* Стандартные хуки для проверки YAML

А вот пример базового pre-commit конфига для нашего проекта в Gitlab CI.

repos:
-   repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.1.0
    hooks:
    -   id: check-yaml
    -   id: check-added-large-files
	
-   repo: https://gitlab.com/devopshq/gitlab-ci-linter
    rev: v1.0.2
    hooks:
    -   id: gitlab-ci-linter
        args:
        - '--server'
        - 'https://gitlab.praktikum-services.ru'
        - '--project'
        - 'erakhmetzyanov/sausage-store'

В дальнейшем наш репозиторий будет пополняться новым кодом для различных инструментов, под которые так же есть хуки, линтеры, анализаторы
